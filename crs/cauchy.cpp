#include "Platform.hpp"
#include "Galois256.hpp"
using namespace cat;

/*
 * Cauchy Reed Solomon (CRS) codes [1]
 *
 * For general purpose error correction under ~32 symbols it is either the best option,
 * or it is more flexible (due to patents/other awkwardness) than the alternatives.
 *
 * CRS codes are parameterized primarily by m, k, and w:
 * 	k = Number of original data blocks.
 * 	m = Number of redundant error correction blocks.
 * 	w = Exponent of the binary extension Galois field used.  eg. GF(2^w)
 *
 * The choice of w limits k and m by the relation: k + m <= 2^w
 * So if w = 8, it can generate up to 256 blocks of original + correction data.
 *
 * In practice if you want to send more than 256 blocks of data there are definitely more
 * efficient options than CRS codes that scale much more gracefully, so w = 8 is a
 * flexible choice that does not require incredibly large tables and does not require an
 * irritating data massaging step to fit it into the field.
 *
 * Note that m = 1 is a degenerate case where the best solution is to just XOR all of the k
 * input data blocks together.  So CRS codes are interesting for 1 < m < 32.
 *
 * These codes have been thoroughly explored by Dr. James Plank over the past ~15 years [1].
 * In this time there has not been a lot of work on improving Jerasure [2] to speed up CRS
 * codes for small datasets.
 *
 * For example, all of the existing work on Jerasure is in reference to disk or cloud
 * storage applications where the file pieces are many megabytes in size.  A neglected area
 * of interest is packet error correction codes, where the data is small and the setup time
 * for the codes is critical.
 *
 * Jerasure is also designed to be generic, so it has best matrices for m = 2 for all of the
 * values of w that may be of interest.  But it does not attempt to optimize for m > 2, which
 * is a huge optimization that is helpful for packet error correction use cases.
 *
 * Jerasure also only tries one generator polynomial for GF(256) instead of exploring all 16
 * of the possible generators to find minimal Cauchy matrices.  I went through the extra
 * work of evaluating all the possible generators to improve on the state of the art.
 *
 * Jerasure also misses a number of opportunities for optimization in the solver that are
 * incorporated to speed up this codec: Windowed back and forward substitution for the
 * Gaussian elimination solver, and solution shortcuts to avoid full diagonalization.
 *
 * [1] "Optimizing Cauchy Reed-Solomon Codes for Fault-Tolerant Storage Applications" (2005)
 *	http://web.eecs.utk.edu/~plank/plank/papers/CS-05-569.pdf
 * [2] "Jerasure 2.0 A Library in C/C++ Facilitating Erasure Coding for Storage Applications" (2014)
 * 	http://jerasure2.googlecode.com/svn/trunk/jerasure3/documentation/paper.pdf
 */

// TODO: Generate best Cauchy matrices for GF(256) generator polynomials

// Cauchy codes with lowest Hamming weight for various m

static const u8 CAUCHY_MATRIX_3[2][253] = {
{0x04 0x10 0x51 0x06 0x05 0x50 0xa2 0x53 0x08 0xeb 0x30 0xa3 0x09 0xb2 0xc3 0x21 0x01,
0x67 0x28 0xa1 0x03 0xb1 0x02 0x9c 0x45 0xe7 0xab 0x0c 0xa6 0x0b 0xc7 0xe9 0xe5,
0xb6 0xe2 0x60 0x92 0x4a 0xcd 0x1c 0x8a 0x61 0x49 0x3a 0xa0 0x2e 0xae 0x12 0xba,
0x54 0x23 0x71 0x18 0x11 0xa4 0x15 0xb9 0x0a 0xb3 0xc9 0xc2 0x91 0x48 0x6a 0x5a,
0x93 0xa8 0x2c 0x65 0x5d 0xb5 0x4b 0xc0 0xd3 0x0d 0xc6 0xea 0x96 0x4f 0x20 0x7c,
0x14 0xdb 0xef 0xd7 0xa7 0x8e 0x59 0xe4 0xb0 0xb7 0xc1 0x24 0x77 0x41 0xff 0x82,
0xfd 0xca 0x0e 0xaa 0x1d 0x69 0xfb 0x3d 0x4d 0x34 0xf9 0xe3 0xbf 0xe1 0x6b 0x62,
0xf3 0xbe 0x2a 0x44 0x2d 0x55 0x94 0x58 0xec 0x64 0x35 0x1e 0x31 0x42 0xa5 0x63,
0x89 0x07 0xf5 0x97 0xbc 0xbb 0xc4 0x88 0x4c 0x8b 0x7d 0x40 0xf2 0xcb 0x38 0xc5,
0x1b 0x78 0xee 0xc8 0x73 0x46 0x36 0xb8 0x43 0x5b 0x80 0xe8 0x52 0xf6 0x3c 0x99,
0x83 0x1a 0x29 0x5c 0x8f 0x26 0xf0 0xfe 0x75 0x76 0x19 0xcc 0x6d 0x22 0x90 0x27,
0xcf 0x6c 0x70 0xd1 0xd5 0x32 0xf8 0x9b 0xd6 0xac 0x84 0x33 0xe6 0xb4 0xed 0xd2,
0xdd 0x68 0x16 0xa9 0x0f 0x39 0x47 0x86 0x2f 0x79 0x13 0x3e 0x95 0x17 0x98 0x9f,
0x1f 0x7a 0x7f 0xf1 0x9a 0x5f 0x3b 0xd0 0x8c 0x56 0x9e 0xdf 0xd8 0x72 0xfa 0x25,
0xbd 0x5e 0x57 0xda 0xd4 0x2b 0xd9 0xfc 0xe0 0x37 0x87 0xde 0xad 0xce 0x74 0xf4,
0xf7 0x66 0x3f 0x4e 0x6f 0x8d 0xaf 0x7e 0x81 0x6e 0xdc 0x9d },
{0x10 0x04 0x06 0x51 0x50 0x05 0x53 0xa2 0xb2 0x30 0xeb 0x09 0xa3 0x08 0x21 0xc3 0x67,
0x01 0xa1 0x28 0xb1 0x03 0x9c 0x02 0xe7 0x45 0x0c 0xab 0x0b 0xa6 0xe9 0xc7 0x60,
0xe2 0xb6 0xe5 0x4a 0x92 0x61 0x8a 0x1c 0xcd 0x3a 0x49 0x2e 0xa0 0x12 0xae 0x54,
0xba 0x18 0x11 0x23 0x71 0x15 0xa4 0x0a 0xb9 0xc9 0xb3 0x6a 0x48 0x91 0xc2 0x93,
0x5a 0x2c 0xa8 0x5d 0x65 0xc0 0x0d 0xb5 0xc6 0x4b 0xd3 0x96 0xea 0x20 0x4f 0x14,
0x7c 0xef 0xdb 0xa7 0xd7 0xb0 0xe4 0x59 0x8e 0x82 0xfd 0x77 0x24 0xff 0x41 0xb7,
0xc1 0xfb 0x1d 0x69 0x0e 0xaa 0xca 0xf3 0x34 0x4d 0x62 0xbf 0xe3 0x6b 0xe1 0xf9,
0x3d 0x2a 0xbe 0x2d 0x44 0x94 0x55 0xec 0x58 0xc4 0x07 0x8b 0xbc 0x4c 0xbb 0x97,
0xcb 0x35 0xf2 0x63 0x31 0xa5 0x64 0x38 0x42 0x1e 0xc5 0x1b 0xf5 0x89 0x88 0x7d,
0x40 0x80 0x3c 0x73 0xc8 0x43 0x5b 0xe8 0x46 0x36 0x78 0xb8 0xf6 0x52 0xee 0x1a,
0x5c 0x99 0xfe 0x83 0x75 0xf0 0x26 0x29 0x8f 0x90 0xcc 0x19 0x70 0x6c 0x76 0xcf,
0x27 0x22 0x6d 0xd5 0xd1 0x84 0xb4 0xd6 0x9b 0xe6 0x32 0xed 0xac 0xf8 0x33 0xa9,
0x16 0x47 0xdd 0xd2 0x39 0x0f 0x68 0x2f 0x86 0x3e 0x95 0x79 0x13 0x9f 0x1f 0x17,
0x98 0xf1 0x9a 0x7a 0x7f 0xd0 0x9e 0x5f 0x56 0x8c 0x3b 0xfa 0x25 0x5e 0xdf 0xd8,
0x57 0x72 0xbd 0xd9 0x2b 0xd4 0xda 0xe0 0xfc 0x74 0xad 0xce 0x87 0xde 0x37 0x66,
0x3f 0xf4 0xf7 0x6f 0x4e 0x85 0x7e 0xaf 0x6e 0x81 0x9d 0xdc },
};



void cauchy_init() {
	GF256Init();
}

/*
 * Number of 1s in Cauchy 8x8 submatrix representation
 *
 * w = 8 so the Cauchy representation is an 8x8 submatrix
 * in place of the GF(256) values of the matrix.
 *
 * To generate the 8x8 submatrix, the first column is the
 * original value in binary.  And the remaining columns
 * are the column to the left times 2 in GF(256).
 */
static const u8 CAUCHY_ONES[256] = {
	0, 8, 13, 21, 18, 22, 23, 27, 20, 28, 25, 33, 26, 30, 27, 31,
	22, 26, 29, 33, 28, 28, 35, 35, 28, 32, 31, 35, 30, 30, 29, 29,
	24, 22, 29, 27, 30, 32, 35, 37, 32, 30, 29, 27, 34, 36, 35, 37,
	30, 32, 33, 35, 32, 38, 35, 41, 32, 34, 31, 33, 30, 36, 25, 31,
	27, 31, 22, 26, 33, 33, 28, 28, 31, 35, 34, 38, 37, 37, 36, 36,
	31, 31, 32, 32, 33, 29, 26, 22, 33, 33, 38, 38, 35, 31, 36, 32,
	33, 31, 32, 30, 35, 37, 34, 36, 33, 31, 40, 38, 35, 37, 38, 40,
	33, 35, 34, 36, 31, 37, 32, 38, 31, 33, 36, 38, 21, 27, 30, 36,
	30, 30, 33, 33, 22, 26, 29, 33, 36, 36, 35, 35, 28, 32, 27, 31,
	32, 28, 37, 33, 36, 36, 37, 37, 40, 36, 37, 33, 36, 36, 33, 33,
	30, 28, 33, 31, 34, 28, 33, 27, 32, 30, 31, 29, 28, 22, 19, 13,
	32, 34, 33, 35, 40, 38, 37, 35, 36, 38, 29, 31, 36, 34, 29, 27,
	35, 35, 32, 32, 35, 39, 28, 32, 37, 37, 38, 38, 33, 37, 34, 38,
	35, 31, 30, 26, 39, 39, 38, 38, 35, 31, 38, 34, 35, 35, 38, 38,
	33, 35, 34, 36, 37, 35, 34, 32, 31, 33, 36, 38, 31, 29, 36, 34,
	29, 35, 32, 38, 37, 39, 36, 38, 17, 23, 28, 34, 29, 31, 32, 34
};

static void cauchy_improve_matrix(int k, int m, u8 *matrix) {
}

static void cauchy_prebuilt_matrix(int k, int m, u8 *matrix) {
	// Attempt to use prebuilt matrices for best performance
	switch (m) {
	case 2:
		for (int x = 0; x < k; ++x) {
			matrix[x] = 1;
			matrix[x + k] = CAUCHY_BEST_2[x];
		}
		return true;
	case 3:
		for (int x = 0; x < k; ++x) {
			matrix[x] = 1;
			matrix[x + k] = CAUCHY_BEST_3[x];
			matrix[x + 2*k] = CAUCHY_BEST_3[x + 255];
		}
		return true;
	case 4:
		for (int x = 0; x < k; ++x) {
			matrix[x] = 1;
			matrix[x + k] = CAUCHY_BEST_4[x];
			matrix[x + 2*k] = CAUCHY_BEST_4[x + 255];
			matrix[x + 3*k] = CAUCHY_BEST_4[x + 255*2];
		}
		return true;
	case 5:
		for (int x = 0; x < k; ++x) {
			matrix[x] = 1;
			matrix[x + k] = CAUCHY_BEST_5[x];
			matrix[x + 2*k] = CAUCHY_BEST_5[x + 255];
			matrix[x + 3*k] = CAUCHY_BEST_5[x + 255*2];
			matrix[x + 4*k] = CAUCHY_BEST_5[x + 255*3];
		}
		return true;
	default:
		break;
	}

	// No prebuilt matrix is available
	return false;
}

bool cauchy_matrix(int k, int m, u8 *matrix) {
	// If input is invalid,
	if (k < 1 || m < 1 || !matrix ||
		k + m > 256) {
		return false;
	}

	// If 4-bit codes are possible,
	if (k + m <= 16) {
		// TODO
	}

	// Attempt to use prebuilt matrices for best performance
	if (cauchy_prebuilt_matrix(k, m, matrix)) {
		return true;
	}

	// Matrix element x, y
	// 	= 1 / (y ^ (m + x)) in GF(256)

	// For each x, y
	for (int y = 0; y < m; ++y) {
		for (int x = 0; x < k; ++x) {
			// Compute element
			matrix[c] = GF256_INV_TABLE[y ^ (m + x)];
		}

		matrix += k;
	}

	return true;
}

